local ffi = require("ffi")
local bit = require("bit")
local band, bnot, rshift = bit.band, bit.bnot, bit.rshift
local engine = engine
local Package = SDKGen.Package
local GeneratedStructs = {}
local DefaultStruct = engine.FindObject("ScriptStruct Core.Default__ScriptStruct", engine.Classes.UScriptStruct)
local STRUCT_ALIGN = 4

local CPF_Const = 0x0000000000000002

-- Add the structs added manually to the generated list so they aren't generated again
local preGenerated = { "Core.Object:Pointer", "Core.Object:QWord" }
for _, structName in ipairs(preGenerated) do
	local struct = engine.FindObject("ScriptStruct " .. structName, engine.Classes.UScriptStruct)
	if NotNull(struct) then
		table.insert(GeneratedStructs, struct)
	end
end

local ScriptStruct = {}
ScriptStruct.__index = ScriptStruct

function ScriptStruct.new(obj)
	return setmetatable({ Struct = ffi.cast("struct UScriptStruct*", obj), UnknownDataIndex = 0, ConsecBools = 0 }, ScriptStruct)
end

function ScriptStruct:GeneratePrereqs(inPackage)
	local scriptStruct = self.Struct
	local structPackage = scriptStruct:GetPackageObject()
	local structText = ""

	if IsNull(structPackage) or structPackage ~= inPackage then
		return structText
	end

	if scriptStruct == DefaultStruct then return end -- Skip the default because it's a dummy
	if table.contains(GeneratedStructs, scriptStruct) then return end -- Skip it if we've already made it

	-- First, check to see if this struct has a base. If it does, make sure we have generated it before
	-- we move on.

	local base = scriptStruct.UStruct.SuperField

	if 	NotNull(base)
		and base ~= scriptStruct
		and not table.contains(GeneratedStructs, base) 
	then
		structText = structText .. ScriptStruct.new(base):GeneratePrereqs(inPackage)
	end

	-- Next, check to see if there are any members of this struct which we haven't yet generated.
	-- If there are, generate them before moving on. There are two cases here: a plain old struct,
	-- and a TArray of structs. There could also be TMap, but this data structure doesn't seem to
	-- be present in BL2.

	local structField = ffi.cast("struct UProperty*", scriptStruct.UStruct.Children)
	while NotNull(structField) do -- Foreach property in the struct

		if structField:IsA(engine.Classes.UStructProperty) then -- If it's a plain old struct
			structField = ffi.cast("struct UStructProperty*", structField)

			local fieldStruct = structField.UStructProperty.Struct

			-- If the struct for this field hasn't been generated, DO IT NOW.
			if 	fieldStruct ~= scriptStruct 
				and not table.contains(GeneratedStructs, fieldStruct) 
			then
				structText = structText .. ScriptStruct.new(structField.UStructProperty.Struct):GeneratePrereqs(inPackage)
			end
		elseif structField:IsA(engine.Classes.UArrayProperty) then
			structField = ffi.cast("struct UArrayProperty*", structField)

			local innerProperty = structField.UArrayProperty.Inner
			if innerProperty:IsA(engine.Classes.UStructProperty) then
				local innerStruct = ffi.cast("struct UStructProperty*", innerProperty).UStructProperty.Struct

				if 	NotNull(innerStruct)
					and innerStruct ~= scriptStruct
					and not table.contains(GeneratedStructs, innerStruct) 
				then
					structText = structText .. ScriptStruct.new(innerStruct):GeneratePrereqs(inPackage)
				end
			end

			-- Check if we need to generate the TArray template for the inner type
			-- and do it if we need to.
			if not SDKGen.TArrayTypes.IsGenerated(innerProperty) then
				SDKGen.TArrayTypes.Generate(innerProperty)
			end
		end

		-- TMap would be here if BL needed it

		structField = ffi.cast("struct UProperty*", structField.UField.Next)
	end

	-- All the requisite structs should have been generated by now, so we can generate this one
	structText = structText .. self:GenerateDefinition()
	return structText
end

function ScriptStruct:GetFieldsSize()
	return self.Struct.UStruct.PropertySize
end

function ScriptStruct:GenerateDefinition()
	local scriptStruct = self.Struct

	SDKGen.DebugPrint("[SDKGen] Struct " .. scriptStruct:GetFullName())

	-- Start by defining the struct with its name
	local count = SDKGen.CountObject(scriptStruct.UObject.Name, engine.Classes.UScriptStruct)
	local structName
	if count == 1 then
		structName = scriptStruct:GetCName()
	else
		structName = scriptStruct.UObject.Outer:GetCName() .. "_" .. scriptStruct:GetCName()
	end
	CURRENT_STRUCT_NAME = structName

	local structText = string.format("// 0x%X ", self:GetFieldsSize())
	if scriptStruct.UStruct.MinAlignment ~= 4 then 
		structText = structText .. string.format("(Alignment = %d)", scriptStruct.UStruct.MinAlignment)
	end

	structText = structText .. "\nstruct " .. structName .. " {\n"

	-- Check if this struct has a base which it inherits from. If it does, instead of doing
	-- some hacky C struct inheritance, just put all the base fields straight into the def
	-- for this struct.
	local base = scriptStruct.UStruct.SuperField
	local actualStart = 0
	if NotNull(base) and base ~= scriptStruct then
		local baseStruct = ScriptStruct.new(base)
		structText = structText .. baseStruct:FieldsToC(0)
		actualStart = actualStart + baseStruct:GetFieldsSize()
	end

	structText = structText .. self:FieldsToC(actualStart)
	structText = structText .. "};\n\n"

	table.insert(GeneratedStructs, scriptStruct)

	return structText
end

function ScriptStruct:FieldsToC(lastOffset)
	local scriptStruct = self.Struct

	-- Foreach property, add them into the properties array
	local properties = {}
	local structProperty = ffi.cast("struct UProperty*", scriptStruct.UStruct.Children)
	while NotNull(structProperty) do
		if structProperty.UProperty.ElementSize > 0 and not structProperty:IsA(engine.Classes.UScriptStruct) then
			table.insert(properties, structProperty)
		end

		structProperty = ffi.cast("struct UProperty*", structProperty.UField.Next)
	end

	-- Next, sort the properties according to their offset in the struct. When dealing with
	-- boolean types, we need the one with the smallest bitmask first.
	table.sort(properties, SDKGen.SortProperty)

	local out = ""
	for _,property in ipairs(properties) do

		-- If the offset for this property is ahead of the end of the last property,
		-- add some unknown data into the struct def.
		if lastOffset < property.UProperty.Offset then
			if self.ConsecBools > 0 then
				out = out .. self:FixBitfields()
			end

			out = out .. self:MissedOffset(lastOffset, (property.UProperty.Offset - lastOffset), "> LAST OFFSET")
		end

		-- Get the type and size of the property
		local typeof = SDKGen.GetPropertyType(property)
		local size = property.UProperty.ElementSize * property.UProperty.ArrayDim

		-- If the type isn't one we recognize, add unknown data to the def.
		if not typeof then
			out = out .. string.format("\tconst unsigned char %s[0x%X]; // 0x%X (0x%X) UNKNOWN PROPERTY\n",
				property:GetName(),
				size,
				property.UProperty.Offset,
				size)
		else
			-- property.UProperty.ElementSize includes the padding of structs, but we don't want
			-- that, because we're going to align things ourselves. Accessing
			-- the PropertySize of the actual struct definition will give us the raw size,
			-- without the extra bytes for alignment
			if property:IsA(engine.Classes.UStructProperty) then
				property = ffi.cast("struct UStructProperty*", property)
				local newSize = SDKGen.Align(property.UStructProperty.Struct.UStruct.PropertySize, 4) * property.UProperty.ArrayDim
				size = newSize
			end

			local constness = ""
			if flags.IsSet(property.UProperty.PropertyFlags.A, CPF_Const) then
				constness = "const "
			end

			local special = ""

			if property.UProperty.ArrayDim > 1 then -- It's a C style array, so [x] needed
				-- LuaJIT has issues here for some reason
				local add = string.format("[%d]", property.UProperty.ArrayDim)
				special = special .. add
			end

			if property:IsA(engine.Classes.UBoolProperty) then
				special = special .. " : 1" -- A bool is defined as a 1 bit unsigned long
				self.ConsecBools = self.ConsecBools + 1

			-- If this property is not a bool, but the previous properties (or property)
			-- have been, then padding might be needed, see FixBitfields()
			elseif self.ConsecBools > 0 then
				out = out .. self:FixBitfields()
 			end

 			-- Byte properties usually mean an enum, so list that
 			local enumName = ""
			if property:IsA(engine.Classes.UByteProperty) then
				property = ffi.cast("struct UByteProperty*", property)
				if NotNull(property.UByteProperty.Enum) then
					enumName = string.format(" (Enum = %s)", property.UByteProperty.Enum:GetName())
				end
			end

			out = out .. string.format("\t%s%s %s%s; // 0x%X (0x%X)%s\n",
				constness,
				typeof,
				property:GetName(),
				special,
				property.UProperty.Offset,
				size,
				enumName)

			debugFile:write("assert(ffi.offsetof(\"struct " .. CURRENT_STRUCT_NAME .. "\", \"" .. property:GetName() .. "\") == " .. tostring(property.UProperty.Offset) .. ")\n")

			-- It's possible that our C definition for this type is not correct
			-- If that's the case, we need to ensure that the fields are still 
			-- at their correct offsets. So here we'll add some data to fix our 
			-- dodgy definition.
			local actualSize = SDKGen.GetCPropertySize(property) * property.UProperty.ArrayDim
			local missedSize = size - actualSize
			if missedSize > 0 then
				out = out .. self:MissedOffset(property.UProperty.Offset + missedSize, missedSize, "PROPERTY C DEF INCORRECT")
			elseif missedSize < 0 then
				error(property.UObject.Class:GetName() .. " has an incorrect C definition (too big)!")
			end
		end

		lastOffset = property.UProperty.Offset + size
	end

	-- Make sure that if the last property was a bitfield, the appropriate padding is added
	if self.ConsecBools > 0 then
		out = out .. self:FixBitfields()
	end

	-- If there is additional data after the last property we have, add it to the end
	if lastOffset < self:GetFieldsSize() then
		local missedSize = self:GetFieldsSize() - lastOffset
		out = out .. self:MissedOffset(lastOffset, missedSize, "MISSING END DATA")
	end

	return out
end

-- See classes.lua for a rant on this
function ScriptStruct:FixBitfields()
	self.ConsecBools = 0
	return "\tconst unsigned long: 0;\n"
end

function ScriptStruct:MissedOffset(at, missedSize, reason)
	if reason == nil then reason = "MISSED OFFSET" end

	self.UnknownDataIndex = self.UnknownDataIndex + 1

	SDKGen.AddError("Missed offset in " .. self.Struct:GetFullName() .. " (Reason = " .. reason .. ")")

	return string.format("\tconst unsigned char Unknown%d[0x%X]; // 0x%X (0x%X) %s\n", 
		self.UnknownDataIndex,
		missedSize,
		at,
		missedSize,
		reason)
end

function Package:ProcessScriptStructs()
	debugFile = file.Open("structtest/" .. self.PackageObj:GetName() .. ".lua", "w+")
	debugFile:write("local ffi = require(\"ffi\")\n\n")

	self:CreateFile("structs")
	self:WriteFileHeader("Script Structs")

	self:WriteCDefWrapperStart()

	-- Foreach object, check if it's a scriptstruct, then check if it's in the package.
	-- If it is, then process the struct
	for i=0,(engine.Objects.Count-1) do

		local obj = engine.Objects[i]
		if IsNull(obj) then goto continue end

		local package_object = obj:GetPackageObject()
		if IsNull(package_object) then goto continue end
		if package_object ~= self.PackageObj then goto continue end

		if not obj:IsA(engine.Classes.UScriptStruct) then goto continue end

		self.File:write(ScriptStruct.new(obj):GeneratePrereqs(self.PackageObj)) -- Generate the requisite structs then generate this one

		::continue:: -- INSERT COIN TO CONTINUE
	end

	self:WriteCDefWrapperEnd()
	self:CloseFile()

	debugFile:write("print(\"Done\")\n")
	debugFile:close()
end
